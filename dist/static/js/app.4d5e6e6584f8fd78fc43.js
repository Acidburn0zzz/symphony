webpackJsonp([1],{"/w9m":function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("Zrlr"),o=a(i),r=t("wxAW"),s=a(r),l=t("Ml+6"),u=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(l),d=t("AjHq"),f=t("8TtI"),c=a(f),m=t("RzKr"),h=a(m),p=t("34JK"),v=a(p),A=t("TKs2"),x=a(A),_=t("Gqez"),g=(a(_),t("F/9K")),F=a(g),P=t("ZlZk"),T=(a(P),t("6bm0")),y=a(T),b=function(){function e(){(0,o.default)(this,e),this.init()}return(0,s.default)(e,[{key:"init",value:function(){this.initScene(),this.initCamera(),this.initRenderer(),this.initPost(),this.addLights(),this.addEvents(),this.resize(),this.animate()}},{key:"initPost",value:function(){this.composer=new d.EffectComposer(this.renderer),this.composer.addPass(new d.RenderPass(this.scene,this.camera)),this.VignettePass=new d.ShaderPass(x.default),this.composer.addPass(this.VignettePass),this.BrightnessContrastPass=new d.ShaderPass(F.default),this.composer.addPass(this.BrightnessContrastPass),this.HueSaturationPass=new d.ShaderPass(h.default),this.composer.addPass(this.HueSaturationPass),this.FXAAPass=new d.ShaderPass(c.default),this.composer.addPass(this.FXAAPass),this.RGBShiftPass=new d.ShaderPass(v.default),this.RGBShiftPass.renderToScreen=!0,this.composer.addPass(this.RGBShiftPass)}},{key:"initScene",value:function(){this.scene=new u.Scene,this.scene.fog=new u.FogExp2(y.default.scene.bgColor,y.default.scene.fogFar),this.scene.background=new u.Color(y.default.scene.bgColor)}},{key:"initCamera",value:function(){this.defaultCameraPos=new u.Vector3(0,0,2500),this.cameraDriftLimitMax={x:100,y:100},this.cameraDriftLimitMin={x:-100,y:-100},this.cameraMoveStep=200,this.cameraLerpSpeed=.03,this.camera=new u.PerspectiveCamera(y.default.camera.fov,window.innerWidth/window.innerHeight,1,5e3),this.camera.position.set(this.defaultCameraPos.x,this.defaultCameraPos.y,this.defaultCameraPos.z),this.camera.updateMatrixWorld(),this.cameraPos=this.camera.position.clone(),this.targetCameraPos=this.cameraPos.clone(),this.cameraLookAtPos=new u.Vector3(0,0,0),this.targetCameraLookAt=new u.Vector3(0,0,0),this.camera.lookAt(this.cameraLookAtPos),this.cameraFromQuaternion=(new u.Quaternion).copy(this.camera.quaternion);var e=(new u.Euler).copy(this.camera.rotation);this.cameraToQuaternion=(new u.Quaternion).setFromEuler(e),this.cameraMoveQuaternion=new u.Quaternion}},{key:"initRenderer",value:function(){this.canvas=document.getElementById("stage"),this.canvas.style.touchAction="none",this.renderer=new u.WebGLRenderer({antialias:y.default.scene.antialias,canvas:this.canvas}),this.renderer.setClearColor(y.default.scene.bgColor,0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.autoClear=!0,this.renderer.sortObjects=!1,this.composer=new d.EffectComposer(this.renderer)}},{key:"addEvents",value:function(){var e=this;this.preUpdate=new Event("preUpdate"),this.postUpdate=new Event("postUpdate"),this.cameraMoveEvent=new Event("cameraMove"),this.mousePos=new u.Vector2,this.targetMousePos=new u.Vector2,document.addEventListener("mousemove",this.onDocumentMouseMove.bind(this),!1),this.canvas.addEventListener("touchmove",function(n){n.preventDefault(),e.onDocumentMouseMove(n.changedTouches[0]||n.touches[0])}),window.addEventListener("resize",this.resize.bind(this),!1)}},{key:"addLights",value:function(){var e=new u.AmbientLight(16777215);this.scene.add(e),this.pointLight=new u.PointLight(16777215,5,5e3,3),this.scene.add(this.pointLight)}},{key:"resize",value:function(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.FXAAPass.material.uniforms.resolution.value=new u.Vector2(1/window.innerWidth,1/window.innerHeight),this.renderer.setSize(window.innerWidth,window.innerHeight),this.composer.setSize(window.innerWidth,window.innerHeight)}},{key:"onDocumentMouseMove",value:function(e){var n=this.renderer.domElement.getBoundingClientRect(),t=e.clientX-n.left,a=e.clientY-n.top;this.targetMousePos.x=t/window.innerWidth*2-1,this.targetMousePos.y=1-a/window.innerHeight*2}},{key:"updateMouse",value:function(){this.mousePos.lerp(new u.Vector2(this.targetMousePos.x,this.targetMousePos.y),this.cameraLerpSpeed)}},{key:"cameraFollowMouse",value:function(){document.dispatchEvent(this.cameraMoveEvent),this.camera.lookAt(this.cameraLookAtPos),this.targetCameraPos.x+=this.mousePos.x,this.targetCameraPos.y+=this.mousePos.y,this.targetCameraPos.x>this.cameraDriftLimitMax.x&&(this.targetCameraPos.x=this.cameraDriftLimitMax.x-1),this.targetCameraPos.y>this.cameraDriftLimitMax.y&&(this.targetCameraPos.y=this.cameraDriftLimitMax.y-1),this.targetCameraPos.x<this.cameraDriftLimitMin.x&&(this.targetCameraPos.x=this.cameraDriftLimitMin.x+1),this.targetCameraPos.y<this.cameraDriftLimitMin.y&&(this.targetCameraPos.y=this.cameraDriftLimitMin.y+1),this.cameraPos.lerp(this.targetCameraPos,this.cameraLerpSpeed),this.camera.position.copy(this.cameraPos),this.cameraLookAtPos.lerp(this.targetCameraLookAt,this.cameraLerpSpeed)}},{key:"update",value:function(){document.dispatchEvent(this.preUpdate),this.updateMouse(),this.cameraFollowMouse(),this.render()}},{key:"render",value:function(){this.composer.render()}},{key:"animate",value:function(){this.reqID=requestAnimationFrame(this.animate.bind(this)),this.update()}}]),e}();n.default=b},0:function(e,n){},"0RWK":function(e,n,t){"use strict";var a=t("gRE1"),i=function(e){return e&&e.__esModule?e:{default:e}}(a);!function(){function n(e,n){var a,o,r;if(e.array&&0!==e.array.length){a=e.array,o="md5",r=!0;var s=t("8yMH"),l=t("PPUF"),u=new s(o,r),d=u.hashElements(a),f=l(d,o),c=void 0;for(var m in f)if(f.hasOwnProperty(m)){var h=f[m];"root"===h.type?h.parent=null:"node"!==h.type&&"leaf"!==h.type||(h.parent=f[h.parent]),"root"!==h.type&&"node"!==h.type||(h.children={},h.children.left=f[h.left],h.children.right=f[h.right],"root"===h.type&&(c=h))}var p=(0,i.default)(f);return p.sort(function(e,n){return n.level-e.level}),{tree:p,sortedTree:c}}return n("An array with at least 1 element is required",null),null}e.exports={fromArray:n}}()},1084:function(e,n){e.exports="#define GLSLIFY 1\nuniform float size;\nuniform float scale;\nuniform float uTime;\nuniform sampler2D uColor;\nuniform float pointCount;\n\nattribute float id;\nvarying float display;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\n\t// get color from texture\n\tvec4 sampleColor = texture2D(uColor, vec2((id / 3.0) / pointCount, 0.0));\n\n\tfloat mod3 = mod(id, 3.0);\n\n\tif (mod3 == 0.0) {\n\t\tdisplay = float(sampleColor.r);\n\t}\n\tif (mod3 == 1.0) {\n\t\tdisplay = float(sampleColor.g);\n\t}\n\tif (mod3 == 2.0) {\n\t\tdisplay = float(sampleColor.b);\n\t}\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"},"1ome":function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("Zx67"),o=a(i),r=t("Zrlr"),s=a(r),l=t("zwoO"),u=a(l),d=t("Pf15"),f=a(d),c=t("Ml+6"),m=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(c),h=t("cNRb"),p=a(h),v=t("w1qT"),A=a(v),x=function(e){function n(e){(0,s.default)(this,n);var t=(0,u.default)(this,(n.__proto__||(0,o.default)(n)).call(this,e));return t.type="ShaderMaterial",t.uniforms=m.ShaderLib.standard.uniforms,t.uniforms.uRefractionRatio={type:"f",value:.8},t.uniforms.uFresnelBias={type:"f",value:.1},t.uniforms.uFresnelScale={type:"f",value:.1},t.uniforms.uFresnelPower={type:"f",value:20},t.vertexShader=p.default,t.fragmentShader=A.default,t}return(0,f.default)(n,e),n}(m.MeshStandardMaterial);n.default=x},"2nw3":function(e,n){e.exports="#define GLSLIFY 1\nuniform vec3 diffuse;\nuniform float opacity;\nuniform float uTime;\nuniform sampler2D uColor;\n\nvarying float display;\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nfloat circle(in float dist, in float radius) {\n\treturn 1.0 - smoothstep(\n\t\tradius - (radius * 10.0),\n\t\tradius + (radius * 0.01),\n        dot(dist, dist) * 3.0\n\t);\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n//\t#include <alphatest_fragment>\n\n\tvec2 uv = ( vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n\tvec2 pos = uv;\n\tpos -= 0.5;\n\n\tfloat dist = length(pos);\n\n\toutgoingLight = diffuseColor.rgb;\n\tvec3 color = vec3(circle(dist, 0.9));\n\tcolor *= sin((dist * 100.0) - (uTime * 30.0));\n\tcolor *= diffuseColor.rgb;\n\tcolor *= display;\n\n\tgl_FragColor = vec4( color, 1.0 );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t//#include <fog_fragment>\n\n}\n"},"34JK":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},amount:{value:65e-5},angle:{value:.1}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float amount;\n    uniform float angle;\n    varying vec2 vUv;\n    void main() {\n    vec2 offset = amount * vec2( cos(angle), sin(angle));\n    vec4 cr = texture2D(tDiffuse, vUv + offset);\n    vec4 cga = texture2D(tDiffuse, vUv);\n    vec4 cb = texture2D(tDiffuse, vUv - offset);\n    gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n    }\n  "};n.default=a},"6bm0":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={daysEitherSide:4,showGUI:!0,scene:{bgColor:2500156,shadowsOn:!1,fogFar:4e-4,antialias:!0},postProcessing:{effectDownscaleDivisor:2},camera:{fov:80}};n.default=a},"8TtI":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("Ml+6"),i=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(a),o={uniforms:{tDiffuse:{value:null},resolution:{value:new i.Vector2(1/window.innerWidth,1/window.innerHeight)}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:'\n    precision highp float;\n\n    uniform sampler2D tDiffuse;\n\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n\n    // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n    //---------------------------------------------------------------------------------\n    // SDK Version: v3.00\n    // Email:       gameworks@nvidia.com\n    // Site:        http://developer.nvidia.com/\n    //\n    // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n    //\n    // Redistribution and use in source and binary forms, with or without\n    // modification, are permitted provided that the following conditions\n    // are met:\n    //  * Redistributions of source code must retain the above copyright\n    //    notice, this list of conditions and the following disclaimer.\n    //  * Redistributions in binary form must reproduce the above copyright\n    //    notice, this list of conditions and the following disclaimer in the\n    //    documentation and/or other materials provided with the distribution.\n    //  * Neither the name of NVIDIA CORPORATION nor the names of its\n    //    contributors may be used to endorse or promote products derived\n    //    from this software without specific prior written permission.\n    //\n    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AS IS AND ANY,\n    // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n    // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n    // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    //\n    //----------------------------------------------------------------------------------\n\n    #define FXAA_PC 1\n    #define FXAA_GLSL_100 1\n    #define FXAA_QUALITY_PRESET 12\n\n    #define FXAA_GREEN_AS_LUMA 1\n\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_PC_CONSOLE\n        //\n        // The console algorithm for PC is included\n        // for developers targeting really low spec machines.\n        // Likely better to just run FXAA_PC, and use a really low preset.\n        //\n        #define FXAA_PC_CONSOLE 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_120\n        #define FXAA_GLSL_120 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_130\n        #define FXAA_GLSL_130 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_3\n        #define FXAA_HLSL_3 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_4\n        #define FXAA_HLSL_4 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_5\n        #define FXAA_HLSL_5 0\n    #endif\n    /*==========================================================================*/\n    #ifndef FXAA_GREEN_AS_LUMA\n        //\n        // For those using non-linear color,\n        // and either not able to get luma in alpha, or not wanting to,\n        // this enables FXAA to run using green as a proxy for luma.\n        // So with this enabled, no need to pack luma in alpha.\n        //\n        // This will turn off AA on anything which lacks some amount of green.\n        // Pure red and blue or combination of only R and B, will get no AA.\n        //\n        // Might want to lower the settings for both,\n        //    fxaaConsoleEdgeThresholdMin\n        //    fxaaQualityEdgeThresholdMin\n        // In order to insure AA does not get turned off on colors\n        // which contain a minor amount of green.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_GREEN_AS_LUMA 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_EARLY_EXIT\n        //\n        // Controls algorithms early exit path.,\n        // On PS3 turning this ON adds 2 cycles to the shader.\n        // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n        // Turning this off on console will result in a more blurry image.\n        // So this defaults to on.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_EARLY_EXIT 1\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_DISCARD\n        //\n        // Only valid for PC OpenGL currently.\n        // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n        //\n        // 1 = Use discard on pixels which dont need AA.,\n        //     For APIs which enable concurrent TEX+ROP from same surface.\n        // 0 = Return unchanged color on pixels which dont need AA.,\n        //\n        #define FXAA_DISCARD 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        //\n        // Used for GLSL 120 only.\n        //\n        // 1 = GL API supports fast pixel offsets\n        // 0 = do not use fast pixel offsets\n        //\n        #ifdef GL_EXT_gpu_shader4\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifndef FXAA_FAST_PIXEL_OFFSET\n            #define FXAA_FAST_PIXEL_OFFSET 0\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GATHER4_ALPHA\n        //\n        // 1 = API supports gather4 on alpha channel.\n        // 0 = API does not support gather4 on alpha channel.\n        //\n        #if (FXAA_HLSL_5 == 1)\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifndef FXAA_GATHER4_ALPHA\n            #define FXAA_GATHER4_ALPHA 0\n        #endif\n    #endif\n\n\n    /*============================================================================\n                            FXAA QUALITY - TUNING KNOBS\n    ------------------------------------------------------------------------------\n    NOTE the other tuning knobs are now in the shader function inputs!\n    ============================================================================*/\n    #ifndef FXAA_QUALITY_PRESET\n        //\n        // Choose the quality preset.\n        // This needs to be compiled into the shader as it effects code.\n        // Best option to include multiple presets is to\n        // in each shader define the preset, then include this file.\n        //\n        // OPTIONS\n        // -----------------------------------------------------------------------\n        // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n        // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n        // 39       - no dither, very expensive\n        //\n        // NOTES\n        // -----------------------------------------------------------------------\n        // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n        // 13 = about same speed as FXAA 3.9 and better than 12\n        // 23 = closest to FXAA 3.9 visually and performance wise\n        //  _ = the lowest digit is directly related to performance\n        // _  = the highest digit is directly related to style\n        //\n        #define FXAA_QUALITY_PRESET 12\n    #endif\n\n\n    /*============================================================================\n\n                               FXAA QUALITY - PRESETS\n\n    ============================================================================*/\n\n    /*============================================================================\n                         FXAA QUALITY - MEDIUM DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 10)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 3.0\n        #define FXAA_QUALITY_P2 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 11)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 3.0\n        #define FXAA_QUALITY_P3 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 12)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 4.0\n        #define FXAA_QUALITY_P4 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 13)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 4.0\n        #define FXAA_QUALITY_P5 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 14)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 4.0\n        #define FXAA_QUALITY_P6 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 15)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 12.0\n    #endif\n\n    /*============================================================================\n                         FXAA QUALITY - LOW DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 20)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 2.0\n        #define FXAA_QUALITY_P2 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 21)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 22)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 23)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 24)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 3.0\n        #define FXAA_QUALITY_P6 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 25)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 26)\n        #define FXAA_QUALITY_PS 9\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 4.0\n        #define FXAA_QUALITY_P8 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 27)\n        #define FXAA_QUALITY_PS 10\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 4.0\n        #define FXAA_QUALITY_P9 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 28)\n        #define FXAA_QUALITY_PS 11\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 4.0\n        #define FXAA_QUALITY_P10 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 29)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n\n    /*============================================================================\n                         FXAA QUALITY - EXTREME QUALITY\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 39)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.0\n        #define FXAA_QUALITY_P2 1.0\n        #define FXAA_QUALITY_P3 1.0\n        #define FXAA_QUALITY_P4 1.0\n        #define FXAA_QUALITY_P5 1.5\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n\n\n\n    /*============================================================================\n\n                                    API PORTING\n\n    ============================================================================*/\n    #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n        #define FxaaBool bool\n        #define FxaaDiscard discard\n        #define FxaaFloat float\n        #define FxaaFloat2 vec2\n        #define FxaaFloat3 vec3\n        #define FxaaFloat4 vec4\n        #define FxaaHalf float\n        #define FxaaHalf2 vec2\n        #define FxaaHalf3 vec3\n        #define FxaaHalf4 vec4\n        #define FxaaInt2 ivec2\n        #define FxaaSat(x) clamp(x, 0.0, 1.0)\n        #define FxaaTex sampler2D\n    #else\n        #define FxaaBool bool\n        #define FxaaDiscard clip(-1)\n        #define FxaaFloat float\n        #define FxaaFloat2 float2\n        #define FxaaFloat3 float3\n        #define FxaaFloat4 float4\n        #define FxaaHalf half\n        #define FxaaHalf2 half2\n        #define FxaaHalf3 half3\n        #define FxaaHalf4 half4\n        #define FxaaSat(x) saturate(x)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_100 == 1)\n      #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_120 == 1)\n        // Requires,\n        //  #version 120\n        // And at least,\n        //  #extension GL_EXT_gpu_shader4 : enable\n        //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n        #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n        #if (FXAA_FAST_PIXEL_OFFSET == 1)\n            #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n        #else\n            #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n        #endif\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_130 == 1)\n        // Requires "#version 130" or better\n        #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_3 == 1)\n        #define FxaaInt2 float2\n        #define FxaaTex sampler2D\n        #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n        #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_4 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_5 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n        #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n        #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n        #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n        #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n    #endif\n\n\n    /*============================================================================\n                       GREEN AS LUMA OPTION SUPPORT FUNCTION\n    ============================================================================*/\n    #if (FXAA_GREEN_AS_LUMA == 0)\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n    #else\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n    #endif\n\n\n\n\n    /*============================================================================\n\n                                 FXAA3 QUALITY - PC\n\n    ============================================================================*/\n    #if (FXAA_PC == 1)\n    /*--------------------------------------------------------------------------*/\n    FxaaFloat4 FxaaPixelShader(\n        //\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy} = center of pixel\n        FxaaFloat2 pos,\n        //\n        // Used only for FXAA Console, and not used on the 360 version.\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy_} = upper left of pixel\n        // {_zw} = lower right of pixel\n        FxaaFloat4 fxaaConsolePosPos,\n        //\n        // Input color texture.\n        // {rgb_} = color in linear or perceptual color space\n        // if (FXAA_GREEN_AS_LUMA == 0)\n        //     {__a} = luma in perceptual color space (not linear)\n        FxaaTex tex,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for "tex".\n        // For 360, same texture, just alias with a 2nd sampler.\n        // This sampler needs to have an exponent bias of -1.\n        FxaaTex fxaaConsole360TexExpBiasNegOne,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for "tex".\n        // For 360, same texture, just alias with a 3nd sampler.\n        // This sampler needs to have an exponent bias of -2.\n        FxaaTex fxaaConsole360TexExpBiasNegTwo,\n        //\n        // Only used on FXAA Quality.\n        // This must be from a constant/uniform.\n        // {x_} = 1.0/screenWidthInPixels\n        // {_y} = 1.0/screenHeightInPixels\n        FxaaFloat2 fxaaQualityRcpFrame,\n        //\n        // Only used on FXAA Console.\n        // This must be from a constant/uniform.\n        // This effects sub-pixel AA quality and inversely sharpness.\n        //   Where N ranges between,\n        //     N = 0.50 (default)\n        //     N = 0.33 (sharper)\n        // {x__} = -N/screenWidthInPixels\n        // {_y_} = -N/screenHeightInPixels\n        // {_z_} =  N/screenWidthInPixels\n        // {__w} =  N/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt,\n        //\n        // Only used on FXAA Console.\n        // Not used on 360, but used on PS3 and PC.\n        // This must be from a constant/uniform.\n        // {x__} = -2.0/screenWidthInPixels\n        // {_y_} = -2.0/screenHeightInPixels\n        // {_z_} =  2.0/screenWidthInPixels\n        // {__w} =  2.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n        //\n        // Only used on FXAA Console.\n        // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n        // This must be from a constant/uniform.\n        // {x__} =  8.0/screenWidthInPixels\n        // {_y_} =  8.0/screenHeightInPixels\n        // {_z_} = -4.0/screenWidthInPixels\n        // {__w} = -4.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_SUBPIX define.\n        // It is here now to allow easier tuning.\n        // Choose the amount of sub-pixel aliasing removal.\n        // This can effect sharpness.\n        //   1.00 - upper limit (softer)\n        //   0.75 - default amount of filtering\n        //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n        //   0.25 - almost off\n        //   0.00 - completely off\n        FxaaFloat fxaaQualitySubpix,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // The minimum amount of local contrast required to apply algorithm.\n        //   0.333 - too little (faster)\n        //   0.250 - low quality\n        //   0.166 - default\n        //   0.125 - high quality\n        //   0.063 - overkill (slower)\n        FxaaFloat fxaaQualityEdgeThreshold,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n        //   0.0625 - high quality (faster)\n        //   0.0312 - visible limit (slower)\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaQualityEdgeThresholdMin,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only three safe values here: 2 and 4 and 8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // For all other platforms can be a non-power of two.\n        //   8.0 is sharper (default!!!)\n        //   4.0 is softer\n        //   2.0 is really soft (good only for vector graphics inputs)\n        FxaaFloat fxaaConsoleEdgeSharpness,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only two safe values here: 1/4 and 1/8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // The console setting has a different mapping than the quality setting.\n        // Other platforms can use other values.\n        //   0.125 leaves less aliasing, but is softer (default!!!)\n        //   0.25 leaves more aliasing, and is sharper\n        FxaaFloat fxaaConsoleEdgeThreshold,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        // The console setting has a different mapping than the quality setting.\n        // This only applies when FXAA_EARLY_EXIT is 1.\n        // This does not apply to PS3,\n        // PS3 was simplified to avoid more shader instructions.\n        //   0.06 - faster but more aliasing in darks\n        //   0.05 - default\n        //   0.04 - slower and less aliasing in darks\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaConsoleEdgeThresholdMin,\n        //\n        // Extra constants for 360 FXAA Console only.\n        // Use zeros or anything else for other platforms.\n        // These must be in physical constant registers and NOT immedates.\n        // Immedates will result in compiler un-optimizing.\n        // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n        FxaaFloat4 fxaaConsole360ConstDir\n    ) {\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posM;\n        posM.x = pos.x;\n        posM.y = pos.y;\n        #if (FXAA_GATHER4_ALPHA == 1)\n            #if (FXAA_DISCARD == 0)\n                FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n                #if (FXAA_GREEN_AS_LUMA == 0)\n                    #define lumaM rgbyM.w\n                #else\n                    #define lumaM rgbyM.y\n                #endif\n            #endif\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n            #else\n                FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n            #endif\n            #if (FXAA_DISCARD == 1)\n                #define lumaM luma4A.w\n            #endif\n            #define lumaE luma4A.z\n            #define lumaS luma4A.x\n            #define lumaSE luma4A.y\n            #define lumaNW luma4B.w\n            #define lumaN luma4B.z\n            #define lumaW luma4B.x\n        #else\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n            #endif\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat maxSM = max(lumaS, lumaM);\n        FxaaFloat minSM = min(lumaS, lumaM);\n        FxaaFloat maxESM = max(lumaE, maxSM);\n        FxaaFloat minESM = min(lumaE, minSM);\n        FxaaFloat maxWN = max(lumaN, lumaW);\n        FxaaFloat minWN = min(lumaN, lumaW);\n        FxaaFloat rangeMax = max(maxWN, maxESM);\n        FxaaFloat rangeMin = min(minWN, minESM);\n        FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n        FxaaFloat range = rangeMax - rangeMin;\n        FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n        FxaaBool earlyExit = range < rangeMaxClamped;\n    /*--------------------------------------------------------------------------*/\n        if(earlyExit)\n            #if (FXAA_DISCARD == 1)\n                FxaaDiscard;\n            #else\n                return rgbyM;\n            #endif\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_GATHER4_ALPHA == 0)\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n            #endif\n        #else\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNS = lumaN + lumaS;\n        FxaaFloat lumaWE = lumaW + lumaE;\n        FxaaFloat subpixRcpRange = 1.0/range;\n        FxaaFloat subpixNSWE = lumaNS + lumaWE;\n        FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n        FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNESE = lumaNE + lumaSE;\n        FxaaFloat lumaNWNE = lumaNW + lumaNE;\n        FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n        FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNWSW = lumaNW + lumaSW;\n        FxaaFloat lumaSWSE = lumaSW + lumaSE;\n        FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n        FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n        FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n        FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n        FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n        FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n        FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n        FxaaBool horzSpan = edgeHorz >= edgeVert;\n        FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    /*--------------------------------------------------------------------------*/\n        if(!horzSpan) lumaN = lumaW;\n        if(!horzSpan) lumaS = lumaE;\n        if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n        FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat gradientN = lumaN - lumaM;\n        FxaaFloat gradientS = lumaS - lumaM;\n        FxaaFloat lumaNN = lumaN + lumaM;\n        FxaaFloat lumaSS = lumaS + lumaM;\n        FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n        FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n        if(pairN) lengthSign = -lengthSign;\n        FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posB;\n        posB.x = posM.x;\n        posB.y = posM.y;\n        FxaaFloat2 offNP;\n        offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n        offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n        if(!horzSpan) posB.x += lengthSign * 0.5;\n        if( horzSpan) posB.y += lengthSign * 0.5;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posN;\n        posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n        posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat2 posP;\n        posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n        posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n        FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n        FxaaFloat subpixE = subpixC * subpixC;\n        FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n    /*--------------------------------------------------------------------------*/\n        if(!pairN) lumaNN = lumaSS;\n        FxaaFloat gradientScaled = gradient * 1.0/4.0;\n        FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n        FxaaFloat subpixF = subpixD * subpixE;\n        FxaaBool lumaMLTZero = lumaMM < 0.0;\n    /*--------------------------------------------------------------------------*/\n        lumaEndN -= lumaNN * 0.5;\n        lumaEndP -= lumaNN * 0.5;\n        FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n        FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n        FxaaBool doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    /*--------------------------------------------------------------------------*/\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 3)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 4)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 5)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 6)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n    /*--------------------------------------------------------------------------*/\n                            #if (FXAA_QUALITY_PS > 7)\n                            if(doneNP) {\n                                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                                doneNP = (!doneN) || (!doneP);\n                                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 8)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 9)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 10)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 11)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 12)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n        #endif\n    /*--------------------------------------------------------------------------*/\n                            }\n                            #endif\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat dstN = posM.x - posN.x;\n        FxaaFloat dstP = posP.x - posM.x;\n        if(!horzSpan) dstN = posM.y - posN.y;\n        if(!horzSpan) dstP = posP.y - posM.y;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n        FxaaFloat spanLength = (dstP + dstN);\n        FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n        FxaaFloat spanLengthRcp = 1.0/spanLength;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool directionN = dstN < dstP;\n        FxaaFloat dst = min(dstN, dstP);\n        FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n        FxaaFloat subpixG = subpixF * subpixF;\n        FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n        FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n        FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n        if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n        if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n        #if (FXAA_DISCARD == 1)\n            return FxaaTexTop(tex, posM);\n        #else\n            return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n        #endif\n    }\n    /*==========================================================================*/\n    #endif\n\n    void main() {\n      gl_FragColor = FxaaPixelShader(\n        vUv,\n        vec4(0.0),\n        tDiffuse,\n        tDiffuse,\n        tDiffuse,\n        resolution,\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.75,\n        0.166,\n        0.0833,\n        0.0,\n        0.0,\n        0.0,\n        vec4(0.0)\n      );\n\n      // TODO avoid querying texture twice for same texel\n      gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n    }\n  '};n.default=o},"8yMH":function(e,n,t){"use strict";!function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"sha256",n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];a=e,i=n}var a,i,o,r=t("TeES");n.prototype.hashElements=function(e,n){if(o=new r,i)for(var t=0;t<e.length;t++){var a=e[t];o.add(a,t)}return o},e.exports=n}()},"9GTs":function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("Zx67"),o=a(i),r=t("Zrlr"),s=a(r),l=t("zwoO"),u=a(l),d=t("Pf15"),f=a(d),c=t("Ml+6"),m=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(c),h=t("1084"),p=a(h),v=t("2nw3"),A=a(v),x=function(e){function n(e){(0,s.default)(this,n);var t=(0,u.default)(this,(n.__proto__||(0,o.default)(n)).call(this,e));return t.type="ShaderMaterial",t.uniforms=m.ShaderLib.points.uniforms,t.uniforms.uTime={type:"f",value:0},t.uniforms.uColor={type:"t"},t.uniforms.pointCount={type:"f"},t.vertexShader=p.default,t.fragmentShader=A.default,t}return(0,f.default)(n,e),n}(m.PointsMaterial);n.default=x},Adlg:function(e,n,t){"use strict";var a=t("Ml+6"),i=(function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);n.default=e}(a),t("uInQ")),o=function(e){return e&&e.__esModule?e:{default:e}}(i);e.exports=function(e){e.addEventListener("message",function(n){var t=n.data;switch(t.cmd){case"build":var a=t.block,i=0;a.fee&&a.input&&(i=a.fee/a.input),a.feeToInputRatio=i;var r=(0,o.default)(a,!0);console.log("Result IS:",r.size);var s={vertices:r.treeGeo.attributes.position.array,size:r.size,boxCenter:r.boxCenter,offset:r.offset,block:a,endPoints:new Float32Array(r.endPoints)};e.postMessage(s);break;case"stop":e.postMessage("WORKER STOPPED"),e.close();break;default:e.postMessage("Unknown command")}e.postMessage(n.data)},!1)}},AjHq:function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0}),n.UnrealBloomPass=n.RenderPass=n.Pass=n.ShaderPass=n.EffectComposer=void 0;var i=t("OvRC"),o=a(i),r=t("woOf"),s=a(r),l=t("Ml+6"),u=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(l),d=t("eyF1"),f=a(d),c=function(e,n){if(this.renderer=e,void 0===n){var t={minFilter:u.LinearFilter,magFilter:u.LinearFilter,format:u.RGBAFormat,stencilBuffer:!1},a=e.getDrawingBufferSize();n=new u.WebGLRenderTarget(a.width,a.height,t),n.texture.name="EffectComposer.rt1"}this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],void 0===f.default&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),void 0===h&&console.error("THREE.EffectComposer relies on THREE.ShaderPass"),this.copyPass=new h(f.default)};(0,s.default)(c.prototype,{swapBuffers:function(){var e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e},addPass:function(e){this.passes.push(e);var n=this.renderer.getDrawingBufferSize();e.setSize(n.width,n.height)},insertPass:function(e,n){this.passes.splice(n,0,e)},render:function(e){var n,t,a=!1,i=this.passes.length;for(t=0;t<i;t++)if(n=this.passes[t],!1!==n.enabled){if(n.render(this.renderer,this.writeBuffer,this.readBuffer,e,a),n.needsSwap){if(a){var o=this.renderer.context;o.stencilFunc(o.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),o.stencilFunc(o.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==u.MaskPass&&(n instanceof u.MaskPass?a=!0:n instanceof u.ClearMaskPass&&(a=!1))}},reset:function(e){if(void 0===e){var n=this.renderer.getDrawingBufferSize();e=this.renderTarget1.clone(),e.setSize(n.width,n.height)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(e,n){this.renderTarget1.setSize(e,n),this.renderTarget2.setSize(e,n);for(var t=0;t<this.passes.length;t++)this.passes[t].setSize(e,n)}});var m=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1};(0,s.default)(m.prototype,{setSize:function(e,n){},render:function(e,n,t,a,i){console.error("Pass: .render() must be implemented in derived pass.")}});var h=function(e,n){m.call(this),this.textureID=void 0!==n?n:"tDiffuse",e instanceof u.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=u.UniformsUtils.clone(e.uniforms),this.material=new u.ShaderMaterial({defines:e.defines||{},uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.camera=new u.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new u.Scene,this.quad=new u.Mesh(new u.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)};h.prototype=(0,s.default)((0,o.default)(m.prototype),{constructor:h,render:function(e,n,t,a,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=t.texture),this.quad.material=this.material,this.renderToScreen?e.render(this.scene,this.camera):e.render(this.scene,this.camera,n,this.clear)}});var p=function(e,n,t,a,i){m.call(this),this.scene=e,this.camera=n,this.overrideMaterial=t,this.clearColor=a,this.clearAlpha=void 0!==i?i:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1};p.prototype=(0,s.default)((0,o.default)(m.prototype),{constructor:p,render:function(e,n,t,a,i){var o=e.autoClear;e.autoClear=!1,this.scene.overrideMaterial=this.overrideMaterial;var r,s;this.clearColor&&(r=e.getClearColor().getHex(),s=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.render(this.scene,this.camera,this.renderToScreen?null:t,this.clear),this.clearColor&&e.setClearColor(r,s),this.scene.overrideMaterial=null,e.autoClear=o}});var v={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{type:"t",value:null},luminosityThreshold:{type:"f",value:1},smoothWidth:{type:"f",value:1},defaultColor:{type:"c",value:new u.Color(0)},defaultOpacity:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec3 defaultColor;","uniform float defaultOpacity;","uniform float luminosityThreshold;","uniform float smoothWidth;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec3 luma = vec3( 0.299, 0.587, 0.114 );","float v = dot( texel.xyz, luma );","vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );","float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );","gl_FragColor = mix( outputColor, texel, alpha );","}"].join("\n")},A=function(e,n,t,a){m.call(this),this.strength=void 0!==n?n:1,this.radius=t,this.threshold=a,this.resolution=void 0!==e?new u.Vector2(e.x,e.y):new u.Vector2(256,256);var i={minFilter:u.LinearFilter,magFilter:u.LinearFilter,format:u.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;var o=Math.round(this.resolution.x/2),r=Math.round(this.resolution.y/2);this.renderTargetBright=new u.WebGLRenderTarget(o,r,i),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(var s=0;s<this.nMips;s++){var l=new u.WebGLRenderTarget(o,r,i);l.texture.name="UnrealBloomPass.h"+s,l.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(l);var l=new u.WebGLRenderTarget(o,r,i);l.texture.name="UnrealBloomPass.v"+s,l.texture.generateMipmaps=!1,this.renderTargetsVertical.push(l),o=Math.round(o/2),r=Math.round(r/2)}void 0===v&&console.error("UnrealBloomPass relies on LuminosityHighPassShader");var d=v;this.highPassUniforms=u.UniformsUtils.clone(d.uniforms),this.highPassUniforms.luminosityThreshold.value=a,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new u.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,defines:{}}),this.separableBlurMaterials=[];for(var c=[3,5,7,9,11],o=Math.round(this.resolution.x/2),r=Math.round(this.resolution.y/2),s=0;s<this.nMips;s++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[s])),this.separableBlurMaterials[s].uniforms.texSize.value=new u.Vector2(o,r),o=Math.round(o/2),r=Math.round(r/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=n,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;var h=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=h,this.bloomTintColors=[new u.Vector3(1,1,1),new u.Vector3(1,1,1),new u.Vector3(1,1,1),new u.Vector3(1,1,1),new u.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,void 0===f.default&&console.error("THREE.BloomPass relies on THREE.CopyShader");var p=f.default;this.copyUniforms=u.UniformsUtils.clone(p.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new u.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:p.vertexShader,fragmentShader:p.fragmentShader,blending:u.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new u.Color,this.oldClearAlpha=1,this.camera=new u.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new u.Scene,this.basic=new u.MeshBasicMaterial,this.quad=new u.Mesh(new u.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)};A.prototype=(0,s.default)((0,o.default)(m.prototype),{constructor:A,dispose:function(){for(var e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(var e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()},setSize:function(e,n){var t=Math.round(e/2),a=Math.round(n/2);this.renderTargetBright.setSize(t,a);for(var i=0;i<this.nMips;i++)this.renderTargetsHorizontal[i].setSize(t,a),this.renderTargetsVertical[i].setSize(t,a),this.separableBlurMaterials[i].uniforms.texSize.value=new u.Vector2(t,a),t=Math.round(t/2),a=Math.round(a/2)},render:function(e,n,t,a,i){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();var o=e.autoClear;e.autoClear=!1,e.setClearColor(new u.Color(0,0,0),0),i&&e.context.disable(e.context.STENCIL_TEST),this.renderToScreen&&(this.quad.material=this.basic,this.basic.map=t.texture,e.render(this.scene,this.camera,void 0,!0)),this.highPassUniforms.tDiffuse.value=t.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.quad.material=this.materialHighPassFilter,e.render(this.scene,this.camera,this.renderTargetBright,!0);for(var r=this.renderTargetBright,s=0;s<this.nMips;s++)this.quad.material=this.separableBlurMaterials[s],this.separableBlurMaterials[s].uniforms.colorTexture.value=r.texture,this.separableBlurMaterials[s].uniforms.direction.value=A.BlurDirectionX,e.render(this.scene,this.camera,this.renderTargetsHorizontal[s],!0),this.separableBlurMaterials[s].uniforms.colorTexture.value=this.renderTargetsHorizontal[s].texture,this.separableBlurMaterials[s].uniforms.direction.value=A.BlurDirectionY,e.render(this.scene,this.camera,this.renderTargetsVertical[s],!0),r=this.renderTargetsVertical[s];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,i&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.render(this.scene,this.camera,void 0,!1):e.render(this.scene,this.camera,t,!1),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=o},getSeperableBlurMaterial:function(e){return new u.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new u.Vector2(.5,.5)},direction:{value:new u.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})},getCompositeMaterial:function(e){return new u.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}}),A.BlurDirectionX=new u.Vector2(1,0),A.BlurDirectionY=new u.Vector2(0,1),n.EffectComposer=c,n.ShaderPass=h,n.Pass=m,n.RenderPass=p,n.UnrealBloomPass=A},"F/9K":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},brightness:{value:0},contrast:{value:.25}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n\n    uniform sampler2D tDiffuse;\n    uniform float brightness;\n    uniform float contrast;\n\n    varying vec2 vUv;\n\n    void main() {\n\n      gl_FragColor = texture2D( tDiffuse, vUv );\n\n      gl_FragColor.rgb += brightness;\n\n      if (contrast > 0.0) {\n        gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\n      } else {\n        gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\n      }\n\n    }\n\n  "};n.default=a},Gqez:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},time:{value:0},nIntensity:{value:.05},sIntensity:{value:0},sCount:{value:0},grayscale:{value:0}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  ",fragmentShader:"\n\n    #include <common>\n\n    // control parameter\n    uniform float time;\n\n    uniform bool grayscale;\n\n    // noise effect intensity value (0 = no effect, 1 = full effect)\n    uniform float nIntensity;\n\n    // scanlines effect intensity value (0 = no effect, 1 = full effect)\n    uniform float sIntensity;\n\n    // scanlines effect count value (0 = no effect, 4096 = full effect)\n    uniform float sCount;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n      // sample the source\n      vec4 cTextureScreen = texture2D( tDiffuse, vUv );\n\n      // make some noise\n      float dx = rand( vUv + time );\n\n      // add noise\n      vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\n\n      // get us a sine and cosine\n      vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\n\n      // add scanlines\n      cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\n      // interpolate between source and result by intensity\n      cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\n      // convert to grayscale if desired\n      if( grayscale ) {\n\n        cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\n      }\n\n      gl_FragColor =  vec4( cResult, cTextureScreen.a );\n\n    }\n\n  "};n.default=a},GuZB:function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("hiCB"),o=a(i),r=t("//Fk"),s=a(r),l=t("Zrlr"),u=a(l),d=t("wxAW"),f=a(d),c=t("Ml+6"),m=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(c),h=t("6bm0"),p=(a(h),t("ZnLv")),v=a(p),A=t("M4fF"),x=(a(A),t("VvTn")),_=function(){function e(n,t){(0,u.default)(this,e),this.samplerLoaded=!1,this.camera=n,this.loops=[],this.quantize=32,this.masterVol=-18,this.ambienceVol=-10,this.path=t,this.ambiencePath=t+"sounds/ambience/mining.mp3",this.bpm=50,this.notes={55:"A1",58.27:"A#1",61.735:"B1",65.406:"C1",69.296:"C#1",73.416:"D1",77.782:"D#1",82.407:"E1",87.307:"F1",92.499:"F#1",97.999:"G1",103.826:"G#1",110:"A2",116.541:"A#2",123.471:"B2",130.813:"C2",138.591:"C#2",146.832:"D2",155.563:"D#2",164.814:"E2",174.614:"F2",184.997:"F#2",195.998:"G2",207.652:"G#2",220:"A3",233.082:"A#3",246.942:"B3",261.626:"C3",277.183:"C#3",293.665:"D3",311.127:"D#3",329.628:"E3",349.228:"F3",369.994:"F#3",391.995:"G3",415.305:"G#3",440:"A4",466.164:"A#4",493.883:"B4",523.251:"C4"},this.pointColors=[],this.modes={ionian:["C","D","E","F","G","A","B","C"],dorian:["C","D","D#","F","G","A","A#","C"],phrygian:["C","C#","D#","F","G","G#","A#","C"],lydian:["C","D","E","F#","G","A","B","C"],mixolydian:["C","D","E","F","G","A","A#","C"],aeolian:["C","D","D#","F","G","G#","A#","C"],locrian:["C","C#","D#","F","F#","G#","A#","C"]},this.audioLoader=new m.AudioLoader}return(0,f.default)(e,[{key:"loadAmbience",value:function(){var e=this;return new s.default(function(n,t){e.ambienceFilter=new v.default.Filter({type:"lowpass",Q:5}).chain(e.ambienceBus),e.ambiencePlayer=new v.default.Player({url:e.ambiencePath,loop:!0,onload:function(){n()}}).chain(e.ambienceBus),e.ambienceBus.volume.linearRampToValueAtTime(e.ambienceVol,20)})}},{key:"setAmbienceFilterCutoff",value:function(e){}},{key:"unloadSound",value:function(){if(this.loops.length){for(var e=0;e<this.loops.length;e++){var n=this.loops[e];n.cancel(),n.dispose()}this.loops=[]}}},{key:"preloadNotes",value:function(){return new s.default(function(e,n){e()})}},{key:"preloadAmbience",value:function(){return new s.default(function(e,n){e()})}},{key:"preload",value:function(){var e=this;return new s.default(function(n,t){e.preloadNotes().then(function(){e.preloadAmbience().then(function(){console.log("sound loaded"),n()})})})}},{key:"init",value:function(){var e=this;return new s.default(function(n,t){e.masterBus=new v.default.Volume(e.masterVol).toMaster(),e.ambienceBus=new v.default.Volume(-96).toMaster(),v.default.Transport.bpm.value=e.bpm,e.loadAmbience().then(function(){e.ambiencePlayer.start(),v.default.Transport.start(),n()})})}},{key:"loadSampler",value:function(){this.sampler=new v.default.Sampler({A1:this.path+"sounds/kalimba/A1.mp3","A#1":this.path+"sounds/kalimba/AS1.mp3",B1:this.path+"sounds/kalimba/B1.mp3",C1:this.path+"sounds/kalimba/C1.mp3","C#1":this.path+"sounds/kalimba/CS1.mp3",D1:this.path+"sounds/kalimba/D1.mp3","D#1":this.path+"sounds/kalimba/DS1.mp3",E1:this.path+"sounds/kalimba/E1.mp3",F1:this.path+"sounds/kalimba/F1.mp3","F#1":this.path+"sounds/kalimba/FS1.mp3",G1:this.path+"sounds/kalimba/G1.mp3","G#1":this.path+"sounds/kalimba/GS1.mp3",A2:this.path+"sounds/kalimba/A2.mp3","A#2":this.path+"sounds/kalimba/AS2.mp3",B2:this.path+"sounds/kalimba/B2.mp3",C2:this.path+"sounds/kalimba/C2.mp3","C#2":this.path+"sounds/kalimba/CS2.mp3",D2:this.path+"sounds/kalimba/D2.mp3","D#2":this.path+"sounds/kalimba/DS2.mp3",E2:this.path+"sounds/kalimba/E2.mp3",F2:this.path+"sounds/kalimba/F2.mp3","F#2":this.path+"sounds/kalimba/FS2.mp3",G2:this.path+"sounds/kalimba/G2.mp3","G#2":this.path+"sounds/kalimba/GS2.mp3",A3:this.path+"sounds/kalimba/A3.mp3","A#3":this.path+"sounds/kalimba/AS3.mp3",B3:this.path+"sounds/kalimba/B3.mp3",C3:this.path+"sounds/kalimba/C3.mp3","C#3":this.path+"sounds/kalimba/CS3.mp3",D3:this.path+"sounds/kalimba/D3.mp3","D#3":this.path+"sounds/kalimba/DS3.mp3",E3:this.path+"sounds/kalimba/E3.mp3",F3:this.path+"sounds/kalimba/F3.mp3","F#3":this.path+"sounds/kalimba/FS3.mp3",G3:this.path+"sounds/kalimba/G3.mp3","G#3":this.path+"sounds/kalimba/GS3.mp3"}).chain(this.masterBus)}},{key:"generateMerkleSound",value:function(e,n,t,a,i){var r=this;this.samplerLoaded||this.loadSampler(),this.samplerLoaded=!0,this.loopMap=[],this.black=new m.Color(0),this.white=new m.Color(16777215),this.pointsMaterial=a;for(var s=o.default,l=0,u=0;u<t.transactions.length;u++){var d=t.transactions[u];s=Math.min(d.time,s),l=Math.max(d.time,l)}t.transactions.sort(function(e,n){return e.time>n.time}),this.pointColors=[];for(var f=0;f<3*e.length;f++)this.pointColors.push(0);for(var c=0;c<e.length;c++){var h;!function(n){var a=e[n];if(void 0!==t.transactions[n]){var i=t.transactions[n],u=(0,x.map)(i.time,s,l,0,30)+1,d=o.default,f="C1",c=r.modes.aeolian;for(h in r.notes)if(r.notes.hasOwnProperty(h)){var m=r.notes[h].replace(/[0-9]/g,"");if(-1!==c.indexOf(m)){var p=Math.abs(2*a-h);p<d&&(d=p,f=r.notes[h])}}var A=r,_=void 0,g=u.toFixed(1);_=void 0===r.loopMap[g]?new v.default.Loop(function(){r.sampler.triggerAttack(f,"@"+A.quantize+"n",1),r.pointColors[3*n]=255,setTimeout(function(){r.pointColors[3*n]=0},500)},"1m").start(v.default.Transport.seconds+u):new v.default.Loop(function(){r.pointColors[3*n]=255,setTimeout(function(){r.pointColors[3*n]=0},500)},"1m").start(v.default.Transport.seconds+u),_.humanize="64n",r.loops.push(_),r.loopMap[g]=!0}}(c)}}}]),e}();n.default=_},MTSG:function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("Zx67"),o=a(i),r=t("Zrlr"),s=a(r),l=t("zwoO"),u=a(l),d=t("Pf15"),f=a(d),c=t("Ml+6"),m=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(c),h=t("1ome"),p=a(h),v=t("k78l"),A=a(v),x=t("TbVk"),_=(a(x),function(e){function n(e){(0,s.default)(this,n);var t=(0,u.default)(this,(n.__proto__||(0,o.default)(n)).call(this,e));return t.type="ShaderMaterial",t.uniforms=m.ShaderLib.standard.uniforms,t.uniforms.uTime={type:"f"},t.uniforms.uAnimTime={type:"f"},t.vertexShader=A.default,t.fragmentShader=A.default,t}return(0,f.default)(n,e),n}(p.default));n.default=_},Mclq:function(e,n,t){"use strict";var a=t("Ml+6"),i=(function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);n.default=e}(a),t("uInQ")),o=function(e){return e&&e.__esModule?e:{default:e}}(i);e.exports=function(e){e.addEventListener("message",function(n){var t=n.data;switch(t.cmd){case"build":var a=t.blocks,i={blockCount:a.length,dayIndex:t.dayIndex,blocks:t.blocks,timeStamp:t.timeStamp,focusOnBlock:t.focusOnBlock};console.time("blocks");for(var r=0;r<a.length;r++){var s=a[r],l=0;s.fee&&s.input&&(l=s.fee/s.input),s.feeToInputRatio=l;var u=(0,o.default)(s),d=u.size;i.blocks[r].feeToInputRatio=l,i.blocks[r].size=d}console.timeEnd("blocks"),e.postMessage(i);break;case"stop":e.postMessage("WORKER STOPPED"),e.close();break;default:e.postMessage("Unknown command")}},!1)}},PPUF:function(e,n,t){"use strict";!function(){function n(e,n,a){var i,o,r,s,l,u,d,f=t("LjEJ"),c=new f,m=new f,h={},p=0,v=e.length;for(i=0;i<v;i++)d=e.get(i),h[d]={type:"leaf",level:p,left:"data",right:"data",parent:""},c.push(d);for(p++;c.length>1;)if(r=c.shift(),s=c.shift(),u=r+s,h[u]={type:"node",level:p,left:r,right:s,parent:""},h[s].parent=u,h[r].parent=u,m.push(u),1===c.length&&(s=c.pop(),u=r+s,h[u]={type:"node",level:p,left:s,right:s,parent:""},h[s].parent=u,m.push(u)),0===c.length&&0!==m.length)for(p++,l=m.length,o=0;o<l;o++)c.push(m.shift());return h[c.pop()].type="root",h}e.exports=n}()},RzKr:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},hue:{value:0},saturation:{value:.5}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float hue;\n    uniform float saturation;\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = texture2D( tDiffuse, vUv );\n\n        // hue\n      float angle = hue * 3.14159265;\n      float s = sin(angle), c = cos(angle);\n      vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n      float len = length(gl_FragColor.rgb);\n      gl_FragColor.rgb = vec3(\n      dot(gl_FragColor.rgb, weights.xyz),\n      dot(gl_FragColor.rgb, weights.zxy),\n      dot(gl_FragColor.rgb, weights.yzx)\n      );\n\n        // saturation\n      float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n      if (saturation > 0.0) {\n        gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n      } else {\n        gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n      }\n\n    }\n  "};n.default=a},TKs2:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},offset:{value:1},darkness:{value:1.4}},vertexShader:"\n\n    varying vec2 vUv;\n\n    void main() {\n\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  ",fragmentShader:'\n\n    uniform float offset;\n    uniform float darkness;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n        // Eskils vignette\n\n    vec4 texel = texture2D( tDiffuse, vUv );\n    vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n    gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n\n        /*\n        // alternative version from glfx.js\n        // this one makes more "dusty" look (as opposed to "burned")\n\n        "vec4 color = texture2D( tDiffuse, vUv );",\n        "float dist = distance( vUv, vec2( 0.5 ) );",\n        "color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",\n        "gl_FragColor = color;",\n        */\n\n    }\n\n  '};n.default=a},TbVk:function(e,n){e.exports="#define GLSLIFY 1\nuniform float uTime;\nuniform float uAnimTime;\n\nvarying float distanceFromCenter;\n\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tfloat radius = uAnimTime;\n\n\tdiffuseColor.a *= (1.0 - step(\n\t\tradius + 0.1,\n        (distanceFromCenter/255.0)\n\t));\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"},VvTn:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=n.PI=Math.PI,i=(n.PI2=2*a,n.HALF_PI=.5*a,n.DEG2RAD=a/180,n.RAD2DEG=180/a,n.step=function(e,n){return n<e?0:1},n.clamp=function(e,n,t){return e<n?n:e>t?t:e}),o=(n.mix=function(e,n,t){return e+(n-e)*t},n.cMix=function(e,n,t){return e+(n-e)*i(t,0,1)},n.unMix=function(e,n,t){return(t-e)/(n-e)},n.cUnMix=function(e,n,t){return i((t-e)/(n-e),0,1)}),r=n.map=function(e,n,t,a,i){return a+(e-n)*(i-a)/(t-n)},s=(n.normalize=function(e,n,t){return r(e,n,t,0,1)},n.smoothstep=function(e,n,t){return(t=o(e,n,t))*t*(3-2*t)},n.fract=function(e){return e-Math.floor(e)}),l=(n.hash=function(e){return s(43758.5453123*Math.sin(e))},n.hash2=function(e,n){return s(43758.5453*Math.sin(12.9898*e+4.1414*n))},n.sign=function(e){return e?e<0?-1:1:0},n.isPowerOfTwo=function(e){return(e&-e)===e}),u=n.powerTwoCeilingBase=function(e){return Math.ceil(Math.log(e)/Math.log(2))},d=(n.powerTwoCeiling=function(e){return l(e)?e:1<<u(e)},n.latLngBearing=function(e,n,t,a){var i=Math.sin(a-n)*Math.cos(t),o=Math.cos(e)*Math.sin(t)-Math.sin(e)*Math.cos(t)*Math.cos(a-n);return Math.atan2(i,o)},n.distanceTo=function(e,n){return Math.sqrt(e*e+n*n)},n.distanceSqrTo=function(e,n){return e*e+n*n},n.distanceTo3=function(e,n,t){return Math.sqrt(e*e+n*n+t*t)},n.distanceSqrTo3=function(e,n,t){return e*e+n*n+t*t},n.latLngDistance=function(e,n,t,a){var i=Math.sin((t-e)/2),o=Math.sin((a-n)/2),r=i*i+Math.cos(e)*Math.cos(t)*o*o;return 2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r))},n.cubicBezier=function(e,n,t,a,i){var o=3*(n-e),r=3*(t-n)-o,s=a-e-o-r,l=i*i;return s*(l*i)+r*l+o*i+e},n.cubicBezierFn=function(e,n,t,a){var i=3*(n-e),o=3*(t-n)-i,r=a-e-i-o;return function(n){var t=n*n;return r*(t*n)+o*t+i*n+e}},n.safeMod=function(e,n){var t=Math.abs(e);return e=e<0?Math.ceil(t/n)*n-t:e,Math.abs(e%n)});n.loop=function(e,n,t){return d(e-n,t-n)+n}},ZlZk:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},h:{value:1/512},r:{value:.35}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float h;","uniform float r;","varying vec2 vUv;","void main() {","vec4 sum = vec4( 0.0 );","float hh = h * abs( r - vUv.y );","sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;","sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;","sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;","sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;","sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;","sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;","sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;","sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;","sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;","gl_FragColor = sum;","}"].join("\n")};n.default=a},cNRb:function(e,n){e.exports="#define GLSLIFY 1\nuniform float uRefractionRatio;\nuniform float uFresnelBias;\nuniform float uFresnelScale;\nuniform float uFresnelPower;\n\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\n//varying float vReflectionFactor;\n\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n\t// vec3 I = worldPosition.xyz - cameraPosition;\n\n\t//vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\t//vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t//vRefract[0] = refract( normalize( I ), worldNormal, uRefractionRatio );\n\t//vRefract[1] = refract( normalize( I ), worldNormal, uRefractionRatio * 0.99 );\n\t//vRefract[2] = refract( normalize( I ), worldNormal, uRefractionRatio * 0.98 );\n\n\t//vReflectionFactor = uFresnelBias + uFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), uFresnelPower );\n\n}\n"},eyF1:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")};n.default=a},f82t:function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("Dd8w"),o=a(i),r=t("Xxa5"),s=a(r),l=t("exGp"),u=a(l),d=t("hiCB"),f=a(d),c=t("c/Tr"),m=a(c),h=t("//Fk"),p=a(h),v=t("fZjL"),A=a(v),x=t("ifoU"),_=a(x),g=t("Zx67"),F=a(g),P=t("Zrlr"),T=a(P),y=t("wxAW"),b=a(y),S=t("zwoO"),L=a(S),N=t("Pf15"),E=a(N),M=t("Ml+6"),w=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(M),I=(t("VvTn"),t("PJh5")),U=a(I),k=t("BzvE"),C=a(k),D=t("M4fF"),X=(a(D),t("6bm0")),O=a(X),R=t("GuZB"),Q=a(R),Y=t("wIG/"),B=a(Y),j=t("1ome"),G=a(j),z=t("9GTs"),H=a(z),V=t("MTSG"),W=a(V),q=t("p5jl"),Z=t("8zBs"),K=Z("Mclq"),J=Z("Adlg"),$=t("pXIW"),ee=function(e){function n(e){var t=e.stage,a=e.path,i=void 0===a?"./static/assets/":a;(0,T.default)(this,n);var o=(0,L.default)(this,(n.__proto__||(0,F.default)(n)).call(this));return o.cubeCamera=null,o.api=new B.default,o.allBlocksObj3d=new _.default,o.allBlocks=new _.default,o.lastHoveredBlock=null,o.stage=t,o.initProperties(),o.initState(),o.addInteraction(),o.audio=new Q.default(o.stage.camera,i),o.audio.init(),o.addEvents(),o.setupMaterials(i),o.initGui(),o.initReflection(),o.clock=new w.Clock,K.addEventListener("message",o.addBlocksToStage.bind(o),!1),o}return(0,E.default)(n,e),(0,b.default)(n,[{key:"destroy",value:function(){document.removeEventListener("preUpdate",this.onUpdateBound,!1),cancelAnimationFrame(this.stage.reqID);var e=(this.stage.scene,function(e){e.geometry&&e.geometry.dispose(),e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose())});this.stage.scene.traverse(e)}},{key:"setDate",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this.state.currentDate&&(this.state.currentDate=e);var t=(0,U.default)(this.state.currentDate),a=(0,U.default)(e),i=t.diff(a,"days"),o=this.dayZOffset*i;this.stage.targetCameraLookAt.z=o,this.stage.targetCameraPos.z=o+this.stage.defaultCameraPos.z,this.state.closestDayIndex=i,this.loadBlocks(a.valueOf(),i,n,i)}},{key:"initReflection",value:function(){}},{key:"initGui",value:function(){if(O.default.showGUI){this.gui=new q.GUI({width:300}),this.gui.open();var e={blockMetalness:.9,blockRoughness:.2,blockColor:this.blockMaterialFront.color.getHex(),blockEmissive:this.blockMaterialFront.emissive.getHex(),blockLightIntesity:5,merkleMetalness:.9,merkleRoughness:.1,merkleColor:this.merkleMaterial.color.getHex(),merkleEmissive:this.merkleMaterial.emissive.getHex(),backgroundColor:O.default.scene.bgColor,vignetteAmount:1.4,cameraFOV:O.default.camera.fov};this.gui.addFolder("Lighting").add(this.stage.pointLight,"intensity",0,10).step(.01);var n=this.gui.addFolder("Scene");n.addColor(e,"backgroundColor").onChange(function(e){this.stage.scene.background=new w.Color(e),this.stage.scene.fog.color=new w.Color(e)}.bind(this)),n.add(e,"vignetteAmount",1,2).step(.01).onChange(function(e){this.stage.VignettePass.uniforms.darkness.value=e}.bind(this)),n.add(e,"cameraFOV",45,100).step(.01).onChange(function(e){this.stage.camera.fov=e,this.stage.camera.updateProjectionMatrix()}.bind(this))}}},{key:"initState",value:function(e,n){this.state={frameCount:0,currentDate:null,dayGroups:[],loadDayRequested:!1,currentBlock:null,currentBlockObject:null,view:"day",dayData:[],currentDay:null,blocksToAnimate:[],closestDayIndex:0,minCameraZPos:0,maxCameraZPos:0}}},{key:"loadBlocks",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.state.loadDayRequested=!0;for(var a in this.state.dayData)this.state.dayData.hasOwnProperty(a)&&Math.abs(a-this.state.closestDayIndex)>O.default.daysEitherSide&&(delete this.state.dayData[a],this.stage.scene.remove(this.state.dayGroups[a]),delete this.state.dayGroups[a]);if(window.Worker){var i=(0,U.default)(e).startOf("day").toDate(),o=(0,U.default)(e).endOf("day").toDate(),r=i.valueOf();this.api.getBlocksSince(i,o).then(function(e){var a={blocks:e,timeStamp:r};K.postMessage({cmd:"build",blocks:a.blocks,timeStamp:a.timeStamp,dayIndex:n,focusOnBlock:t})})}else console.log("Webworkers not supported. Sad")}},{key:"addBlocksToStage",value:function(e){var n=e.data;try{var t=(n.sizes,n.blockCount,n.timeStamp),a=n.dayIndex,i=n.blocks,o=n.focusOnBlock;this.state.dayData[a]={blocks:i,timeStamp:t,blockMaterialFront:this.blockMaterialFront.clone(),blockMaterialBack:this.blockMaterialBack.clone(),merkleMaterial:this.merkleMaterial.clone(),visibleCount:0};var r=new w.Group;this.state.dayGroups[a]=r,this.stage.scene.add(r),this.blocksToAnimate=[];for(var s=0;s<i.length;s++){var l=i[s],u=l.size;if(0!==u.x&&0!==u.y&&0!==u.z){var d=new w.Mesh(this.boxGeometry,this.state.dayData[a].blockMaterialFront),f=new w.Mesh(this.boxGeometry,this.state.dayData[a].blockMaterialBack);d.name="front",f.name="back",f.renderOrder=s-1*-a+1e6,d.renderOrder=s*-a+1e6,d.scale.set(u.x,u.y,u.z),f.scale.set(u.x,u.y,u.z);var c=-25*Math.PI/200*s;l.dayIndex=a;var m=new w.Group;m.materials={front:this.state.dayData[a].blockMaterialFront,back:this.state.dayData[a].blockMaterialBack},m.front=d,m.back=f,m.blockchainData=l,m.rotation.z=c,m.translateY(800+s),m.rotation.z+=Math.PI/2,m.translateZ(30*s),this.allBlocksObj3d.set(l.hash,m),this.allBlocks.set(m,l),m.visible=!1,m.add(f),m.add(d),r.add(m)}}var h=this.dayZOffset*a;r.translateZ(h),this.state.dayData[a].zPos=h,this.state.loadDayRequested=!1;var p=this;if((0,A.default)(this.state.dayGroups).forEach(function(e){var n=p.state.dayGroups[e];p.stage.scene.remove(n)}),(0,A.default)(this.state.dayGroups).reverse().forEach(function(e){var n=p.state.dayGroups[e];p.stage.scene.add(n)}),o)for(var v=0;v<this.state.dayGroups[a].children.length;v++){var x=this.state.dayGroups[a].children[v];if(x.blockchainData.hash===this.state.currentHash){this.focusOnBlock(x);break}}}catch(e){console.log(e)}}},{key:"initProperties",value:function(){this.boxGeometry=new w.BoxBufferGeometry(1,1,1),this.dayZOffset=-5500,this.treeGroup=null,this.blockLoadZThreshold=1e4,this.crystalOpacity=.5,this.pointLightTarget=new w.Vector3(0,0,0),this.cameraBlockFocusDistance=300}},{key:"addInteraction",value:function(){this.raycaster=new w.Raycaster,this.intersected=null}},{key:"addEvents",value:function(){this.onUpdateBound=this.onUpdate.bind(this),document.addEventListener("preUpdate",this.onUpdateBound,!1),document.addEventListener("cameraMove",this.onCameraMove.bind(this),!1),this.selectBlock=new Event("selectBlock"),this.dayChangedEvent=document.createEvent("CustomEvent"),document.addEventListener("mousedown",this.onDocumentMouseDown.bind(this),!1),document.addEventListener("touchend",this.onDocumentMouseDown.bind(this),!1),window.Worker&&(this.treeBuilderWorker=J,this.treeBuilderWorker.addEventListener("message",this.addTreeToStage.bind(this),!1))}},{key:"addTreeToStage",value:function(e){var n=e.data,t=(n.boxCenter,n.offset),a=(n.sie,n.vertices),i=n.endPoints,o=n.block;if(a){this.state.currentBlockObject&&(this.state.currentBlockObject.remove(this.state.currentBlockObject.tree),this.audio.unloadSound());var r=this.state.currentBlockObject.getWorldPosition().clone(),s=new w.BufferGeometry;s.addAttribute("position",new w.BufferAttribute(a,3)),s.computeVertexNormals(),s.computeFaceNormals();var l=new w.Mesh(s,this.state.dayData[o.dayIndex].merkleMaterial);l.position.add(t),l.renderOrder=1e7,l.onBeforeRender=function(e){return e.clearDepth()};var u=new w.BufferAttribute(i,3,1),d=new Array(i.length/3).fill(0).map(function(e,n){return n}),f=new w.BufferGeometry;f.addAttribute("position",u),f.addAttribute("id",new w.BufferAttribute(new Float32Array(d),1,1));var c=new w.Points(f,this.pointsMaterial);c.position.add(t);var m=this.allBlocksObj3d.get(o.hash);m.add(c),m.add(l),m.tree=l,this.merkleMaterial.uniforms.uAnimTime.value=0,this.audio.generateMerkleSound(i,r,o,this.pointsMaterial,c)}}},{key:"resetDayView",value:function(){var e=this;this.state.isAnimating||(this.audio.unloadSound(),this.state.currentBlockObject?(this.state.currentBlockObject.remove(this.state.currentBlockObject.tree),this.animateBlockOut(this.state.currentBlockObject).then(function(){e.state.currentBlockObject=null,e.state.view="day"})):this.state.view="day")}},{key:"onDocumentMouseDown",value:function(e){if(e.preventDefault(),!document.querySelector(".dg.ac").contains(e.target)&&!this.state.isAnimating){var n=this.getIntersections(),t=n.intersected;t&&t!==this.state.currentBlockObject?this.focusOnBlock(t):this.resetDayView()}}},{key:"createCubeMap",value:function(e,n){if(void 0!==this.state.dayData[n]){this.stage.scene.background=this.bgMap,this.state.dayData[n].blockMaterialFront.color.setHex(16777215);var t=new w.CubeCamera(100,5e3,1024);t.position.set(e.x,e.y,e.z),t.renderTarget.texture.minFilter=w.LinearMipMapLinearFilter,t.update(this.stage.renderer,this.stage.scene),this.state.dayData[n].blockMaterialFront.envMap=t.renderTarget.texture,this.state.dayData[n].blockMaterialBack.envMap=t.renderTarget.texture,this.state.dayData[n].merkleMaterial.envMap=t.renderTarget.texture,this.stage.scene.background=new w.Color(O.default.scene.bgColor)}}},{key:"animateBlock",value:function(e,n,t,a,i,o){var r=this;return new p.default(function(n,s){r.state.isAnimating=!0;var l=new w.Quaternion;e.quaternion.set(l),r.easing=$.Easing.Quartic.InOut,new $.Tween(e.position).to(a,o).easing(r.easing).onComplete(function(){r.state.isAnimating=!1,n()}).start(),new $.Tween({time:0}).to({time:1},o).onUpdate(function(n){var a=n.time;w.Quaternion.slerp(t,i,l,a),e.quaternion.set(l.x,l.y,l.z,l.w)}).easing(r.easing).start()})}},{key:"animateBlockOut",value:function(e){var n=this;return new p.default(function(t,a){if(e){var i=e.position.clone(),o=e.initialPosition.clone(),r=e.initialRotation.clone(),s=(new w.Quaternion).copy(e.quaternion),l=(new w.Quaternion).setFromEuler(r);n.animateBlock(e,i,s,o,l,500).then(function(){t()})}else t()})}},{key:"animateBlockIn",value:function(e){var n=this;return new p.default(function(t,a){var i=e.position.clone(),o=new w.Euler(0,0,0),r=(new w.Quaternion).copy(e.quaternion),s=(new w.Quaternion).setFromEuler(o);e.initialPosition=e.position.clone(),e.initialRotation=e.rotation.clone();var l=e.getWorldPosition();n.stage.targetCameraLookAt.z=l.z,n.stage.targetCameraPos.z=l.z+n.cameraBlockFocusDistance;var u=new w.Vector3;u.z=e.position.z,n.animateBlock(e,i,r,u,s,2e3,!0).then(function(){t()})})}},{key:"buildTree",value:function(e){var n=this,t=e.blockchainData;this.state.currentBlockObject&&(this.state.currentBlockObject.remove(this.state.currentBlockObject.tree),this.audio.unloadSound()),this.state.currentBlock=t,this.api.getTransactionsForBlock(t.hash).then(function(e){t.transactions=e,console.log("Building Tree for",t.hash),n.treeBuilderWorker.postMessage({cmd:"build",block:t})}).catch(function(e){console.log(e)})}},{key:"setupMaterials",value:function(e){this.cubeMapUrls=["px.png","nx.png","py.png","ny.png","pz.png","nz.png"];var n=((new w.TextureLoader).load(e+"textures/Marble068_COL_1K.jpg"),(new w.TextureLoader).load(e+"textures/Marble068_REFL_1K.jpg")),t=(new w.TextureLoader).load(e+"textures/Marble068_GLOSS_1K.jpg"),a=((new w.TextureLoader).load(e+"textures/Marble068_GLOSS_1K.jpg"),(new w.TextureLoader).load(e+"textures/Marble068_NRM_1K.jpg")),i=(new w.TextureLoader).load(e+"textures/IceBlock008_OVERLAY_1K.jpg");this.bgMap=(new w.CubeTextureLoader).setPath(e+"textures/").load(this.cubeMapUrls),this.blockMaterialBack=new G.default({color:15658734,emissive:0,metalness:.9,roughness:.2,opacity:.5,transparent:!0,side:w.BackSide,envMap:this.bgMap,bumpMap:i,bumpScale:.03}),this.blockMaterialFront=new G.default({color:15658734,emissive:3342336,metalness:.9,roughness:.2,opacity:.5,transparent:!0,side:w.FrontSide,envMap:this.bgMap,bumpMap:i,bumpScale:.03}),this.centralBlockMaterial=new w.MeshPhysicalMaterial({color:16777215,emissive:3355443,metalness:.8,roughness:.2,opacity:.5,transparent:!0,side:w.DoubleSide,envMap:this.bgMap,envMapIntensity:2.3,roughnessMap:t,metalnessMap:n,normalMap:a,premultipliedAlpha:!0}),this.blockMaterialOutline=new w.LineBasicMaterial({color:11184810,transparent:!0,opacity:.5}),this.blockMaterialHighlight=new w.MeshPhysicalMaterial({color:16777215,emissive:16777215,metalness:.9,roughness:.2,opacity:.8,transparent:!0,side:w.DoubleSide}),this.merkleMaterial=new W.default({color:16777215,emissive:4473924,flatShading:!0,metalness:.8,roughness:.3,opacity:.3,transparent:!0,side:w.DoubleSide,envMap:this.bgMap}),this.pointsMaterial=new H.default({color:16775424,size:30,transparent:!0,blending:w.AdditiveBlending,opacity:1,depthTest:!1})}},{key:"getIntersections",value:function(){var e=new w.Vector3(this.stage.targetMousePos.x,this.stage.targetMousePos.y,.5);e.unproject(this.stage.camera);var n=new w.Raycaster(this.stage.camera.position,e.sub(this.stage.camera.position).normalize()),t=(0,m.default)(this.allBlocksObj3d.values()),a=t.map(function(e){return e.children[0]}).filter(function(e){return e&&e.visible}),i=n.intersectObjects(a,!1);return{intersections:i,allBlocks:t,intersected:i[0]&&i[0].object.parent}}},{key:"checkMouseIntersection",value:function(){var e=this,n=this.getIntersections(),t=n.intersected;n.allBlocks.forEach(function(e){e.front.material=e.materials.front,e.back.material=e.materials.back}),t&&t!==this.state.currentBlockObject&&(t.children.forEach(function(n){return n.material=e.blockMaterialHighlight}),t!==this.lastHoveredBlock&&(this.lastHoveredBlock=t,this.emit("blockHovered",this.allBlocks.get(t))),this.pointLightTarget=t.position)}},{key:"onCameraMove",value:function(){if(void 0!==this.state.dayData[0]){var e=Number.MAX_VALUE,n=0;for(var t in this.state.dayData)if(this.state.dayData.hasOwnProperty(t)){var a=this.state.dayData[t],i=Math.abs(a.zPos-this.stage.camera.position.z+1e3);i<e&&(e=i,n=parseInt(t))}var o=this.state.dayData[n].blocks,r=1e3*o[0].time,s=(0,U.default)(r).startOf("day").toDate(),l={date:s,input:o.reduce(function(e,n){return e+n.input},0),output:o.reduce(function(e,n){return e+n.output},0),fee:o.reduce(function(e,n){return e+n.fee},0)};if(null===this.state.currentDay?(this.emit("firstDayLoaded"),this.emit("dayChanged",l)):this.state.closestDayIndex!==n&&this.emit("dayChanged",l),this.state.currentDay=this.state.dayData[n],this.state.closestDayIndex=n,!1===this.state.loadDayRequested&&void 0!==this.state.currentDay)for(var u=0;u<=O.default.daysEitherSide;u++){for(var d=!1,f=0;f<=1;f++){var c=parseFloat(u);if(1===f&&0!==u&&(c=-1*u),void 0===this.state.dayData[n+c]){var m=(0,U.default)(this.state.currentDay.timeStamp).subtract(c,"day").format("YYYY-MM-DD");this.loadDay(m,n,c),d=!0;break}}if(d)break}}}},{key:"loadDay",value:function(e,n,t){this.loadBlocks(e,n+t);var a=f.default,i=0;for(var o in this.state.dayData)if(this.state.dayData.hasOwnProperty(o)){var r=this.state.dayData[o];r.blocks.length>0&&(a=Math.min(a,parseInt(o)),i=Math.max(i,parseInt(o)))}void 0!==this.state.dayData[a]&&void 0!==this.state.dayData[i]&&(this.state.maxCameraZPos=this.state.dayData[a].zPos+this.stage.defaultCameraPos.z,this.state.minCameraZPos=this.state.dayData[i].zPos+1e3)}},{key:"goToBlock",value:function(){function e(e){return n.apply(this,arguments)}var n=(0,u.default)(s.default.mark(function e(n){var t,a,i;return s.default.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n){e.next=2;break}return e.abrupt("return");case 2:if(t=(0,m.default)(this.allBlocks.values()).find(function(e){return e.hash===n}),a=t,t){e.next=8;break}return e.next=7,this.api.getBlock(hash);case 7:a=e.sent;case 8:i=(0,U.default)(1e3*a.time).format("YYYY-MM-DD"),this.state.currentHash=a.hash,this.setDate(i,!0);case 11:case"end":return e.stop()}},e,this)}));return e}()},{key:"focusOnBlock",value:function(e){var n=this;e.visible=!0,this.state.view="block",this.animateBlockOut(this.state.currentBlockObject).then(function(){n.state.currentBlockObject&&(n.state.currentBlockObject.remove(n.state.currentBlockObject.tree),n.audio.unloadSound()),n.state.currentBlockObject=e,n.animateBlockIn(n.state.currentBlockObject).then(function(){n.buildTree(n.state.currentBlockObject),n.state.isAnimating=!1;var e=n.state.currentBlockObject.blockchainData;n.emit("blockSelected",(0,o.default)({},e,{time:new Date(1e3*e.time)}))})})}},{key:"animateTree",value:function(){}},{key:"animateBlockVisibility",value:function(){for(var e in this.state.dayGroups)if(this.state.dayGroups.hasOwnProperty(e)){var n=this.state.dayGroups[e];if(void 0!==this.state.dayData[e]&&this.state.dayData[e].visibleCount<n.children.length){for(var t=0;t<n.children.length;t++){var a=n.children[t];if(!1===a.visible){a.visible=!0,this.state.dayData[e].visibleCount++;break}}this.state.dayData[e].visibleCount===n.children.length&&this.createCubeMap(n.getWorldPosition(),e)}}}},{key:"updateLights",value:function(){this.stage.pointLight.position.lerp(this.pointLightTarget,.5)}},{key:"onUpdate",value:function(){if(this.state.frameCount++,$.update(),this.updateLights(),this.checkMouseIntersection(),this.animateTree(),this.animateBlockVisibility(),this.uTime=this.clock.getElapsedTime(),this.pointsMaterial.uniforms.uTime.value=this.uTime,this.merkleMaterial&&(this.merkleMaterial.uniforms.uAnimTime.value+=.01,this.merkleMaterial.uniforms.uTime.value=this.uTime),void 0!==this.audio.pointColors&&this.audio.pointColors.length>0){var e=Uint8Array.from(this.audio.pointColors),n=new w.DataTexture(e,e.length/3,1,w.RGBFormat);n.minFilter=w.NearestFilter,n.magFilter=w.NearestFilter,n.needsUpdate=!0,this.pointsMaterial.uniforms.uColor.value=n,this.pointsMaterial.uniforms.pointCount.value=e.length/3}}}]),n}(C.default);n.default=ee},fnz4:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.merge=void 0;var a=t("Ml+6"),i=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(a);n.merge=function(e,n){if(n instanceof i.BufferGeometry==!1)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);var t=e.attributes;if(e.index){for(var a=n.index.array,o=t.position.count,r=0,s=a.length;r<s;r++)a[r]=o+a[r];e.index.array=function(e,n){var t=e.length,a=new Uint32Array(t+n.length);return a.set(e),a.set(n,t),a}(e.index.array,a)}for(var l in t)void 0!==n.attributes[l]&&(t[l].array=function(e,n){var t=e.length,a=new Float32Array(t+n.length);return a.set(e),a.set(n,t),a}(t[l].array,n.attributes[l].array));return e}},k78l:function(e,n){e.exports="#define GLSLIFY 1\nuniform float uTime;\nuniform float uAnimTime;\n\nvarying float distanceFromCenter;\n\nfloat random_1_0 (vec2 st_1_1) {\n    return fract(sin(dot(st_1_1.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n\n\n\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\tdistanceFromCenter = distance(transformed.xyz, vec3(0.0, 0.0, 0.0)) + (random_1_0(transformed.xy) * 100.0 );\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n"},uInQ:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("Ml+6"),i=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(a),o=t("0RWK"),r=function(e){return e&&e.__esModule?e:{default:e}}(o),s=(t("fnz4"),t("H/Ud")),l=(new i.LineCurve3,new i.Vector3,new i.Vector3,new i.Quaternion),u=Math.PI/180,d=new i.Vector3(1,0,0),f=new i.Vector3(0,1,0),c=new i.Vector3(0,0,1),m=new i.Vector3(0,1,0),h=new i.Quaternion,p=new i.Quaternion,v=new i.Quaternion,A=new i.Quaternion,x=new i.Quaternion,_=new i.Quaternion,g=new i.Quaternion;n.default=function(e){var n=e.n_tx,t=e.output,a=e.hash,o=e.feeToInputRatio,F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=new i.Geometry,T=5+t%85;T=5*Math.ceil(T/5);var y=T,b=new i.LineCurve3;h.setFromAxisAngle(d,u*y),p.setFromAxisAngle(d,u*-y),v.setFromAxisAngle(f,u*y),A.setFromAxisAngle(f,u*-y),x.setFromAxisAngle(f,180*u),_.setFromAxisAngle(c,u*y),g.setFromAxisAngle(c,u*-y);var S=new Array(n).fill(0).map(function(e,n){return n.toString()}),L=r.default.fromArray({array:S}),N=L.tree,E=(L.sortedTree,0);N[0].direction=new i.Vector3(0,1,0),N[0].startPosition=new i.Vector3(0,0,0);for(var M=new i.Vector3(m),w=f,I=[],U=[],k=new i.Vector3,C=new i.Vector3,D=void 0,X=N[0].level,O=new Array(X).fill(0).map(function(e){return s(a+e)}),R=N.length,Q=0,Y=void 0;Q<R;){if(Y=N[Q++],M.copy(m),Y.parent){Y.startPosition=Y.parent.endPosition;E+=(1e4*O[Y.level].quick()-5e3)*o,M.copy(Y.parent.endPosition).sub(Y.parent.startPosition);var B=Y.parent.children.left===Y;M.applyQuaternion(B?_:g),M.applyQuaternion(l.setFromAxisAngle(w,u*E))}if(D=5*(Y.level+1),M.normalize().multiplyScalar(D),Y.endPosition=Y.startPosition.clone().add(M),C.max(Y.endPosition),k.min(Y.endPosition),I.push(Y.endPosition.clone()),I.push(Y.startPosition.clone()),F){0===Y.level&&U.push(Y.endPosition.x,Y.endPosition.y,Y.endPosition.z),b.v1.copy(Y.startPosition),b.v2.copy(Y.endPosition);var j=new i.TubeGeometry(b,1,D/20,6,!1);P.merge(j)}1===Y.level&&U.push(Y.endPosition.x,Y.endPosition.y,Y.endPosition.z)}var G=(new i.Box3).setFromPoints(I),z=G.getSize(),H=(G.getCenter(),(new i.Vector3).sub(k).sub(z.clone().multiplyScalar(.5))),V=new i.BufferGeometry;return F&&V.fromGeometry(P),{size:z,offset:H,boxCenter:k,endPoints:U,treeGeo:V}}},uslO:function(e,n,t){function a(e){return t(i(e))}function i(e){var n=o[e];if(!(n+1))throw new Error("Cannot find module '"+e+"'.");return n}var o={"./af":"3CJN","./af.js":"3CJN","./ar":"3MVc","./ar-dz":"tkWw","./ar-dz.js":"tkWw","./ar-kw":"j8cJ","./ar-kw.js":"j8cJ","./ar-ly":"wPpW","./ar-ly.js":"wPpW","./ar-ma":"dURR","./ar-ma.js":"dURR","./ar-sa":"7OnE","./ar-sa.js":"7OnE","./ar-tn":"BEem","./ar-tn.js":"BEem","./ar.js":"3MVc","./az":"eHwN","./az.js":"eHwN","./be":"3hfc","./be.js":"3hfc","./bg":"lOED","./bg.js":"lOED","./bm":"hng5","./bm.js":"hng5","./bn":"aM0x","./bn.js":"aM0x","./bo":"w2Hs","./bo.js":"w2Hs","./br":"OSsP","./br.js":"OSsP","./bs":"aqvp","./bs.js":"aqvp","./ca":"wIgY","./ca.js":"wIgY","./cs":"ssxj","./cs.js":"ssxj","./cv":"N3vo","./cv.js":"N3vo","./cy":"ZFGz","./cy.js":"ZFGz","./da":"YBA/","./da.js":"YBA/","./de":"DOkx","./de-at":"8v14","./de-at.js":"8v14","./de-ch":"Frex","./de-ch.js":"Frex","./de.js":"DOkx","./dv":"rIuo","./dv.js":"rIuo","./el":"CFqe","./el.js":"CFqe","./en-au":"Sjoy","./en-au.js":"Sjoy","./en-ca":"Tqun","./en-ca.js":"Tqun","./en-gb":"hPuz","./en-gb.js":"hPuz","./en-ie":"ALEw","./en-ie.js":"ALEw","./en-nz":"dyB6","./en-nz.js":"dyB6","./eo":"Nd3h","./eo.js":"Nd3h","./es":"LT9G","./es-do":"7MHZ","./es-do.js":"7MHZ","./es-us":"INcR","./es-us.js":"INcR","./es.js":"LT9G","./et":"XlWM","./et.js":"XlWM","./eu":"sqLM","./eu.js":"sqLM","./fa":"2pmY","./fa.js":"2pmY","./fi":"nS2h","./fi.js":"nS2h","./fo":"OVPi","./fo.js":"OVPi","./fr":"tzHd","./fr-ca":"bXQP","./fr-ca.js":"bXQP","./fr-ch":"VK9h","./fr-ch.js":"VK9h","./fr.js":"tzHd","./fy":"g7KF","./fy.js":"g7KF","./gd":"nLOz","./gd.js":"nLOz","./gl":"FuaP","./gl.js":"FuaP","./gom-latn":"+27R","./gom-latn.js":"+27R","./gu":"rtsW","./gu.js":"rtsW","./he":"Nzt2","./he.js":"Nzt2","./hi":"ETHv","./hi.js":"ETHv","./hr":"V4qH","./hr.js":"V4qH","./hu":"xne+","./hu.js":"xne+","./hy-am":"GrS7","./hy-am.js":"GrS7","./id":"yRTJ","./id.js":"yRTJ","./is":"upln","./is.js":"upln","./it":"FKXc","./it.js":"FKXc","./ja":"ORgI","./ja.js":"ORgI","./jv":"JwiF","./jv.js":"JwiF","./ka":"RnJI","./ka.js":"RnJI","./kk":"j+vx","./kk.js":"j+vx","./km":"5j66","./km.js":"5j66","./kn":"gEQe","./kn.js":"gEQe","./ko":"eBB/","./ko.js":"eBB/","./ky":"6cf8","./ky.js":"6cf8","./lb":"z3hR","./lb.js":"z3hR","./lo":"nE8X","./lo.js":"nE8X","./lt":"/6P1","./lt.js":"/6P1","./lv":"jxEH","./lv.js":"jxEH","./me":"svD2","./me.js":"svD2","./mi":"gEU3","./mi.js":"gEU3","./mk":"Ab7C","./mk.js":"Ab7C","./ml":"oo1B","./ml.js":"oo1B","./mr":"5vPg","./mr.js":"5vPg","./ms":"ooba","./ms-my":"G++c","./ms-my.js":"G++c","./ms.js":"ooba","./mt":"oCzW","./mt.js":"oCzW","./my":"F+2e","./my.js":"F+2e","./nb":"FlzV","./nb.js":"FlzV","./ne":"/mhn","./ne.js":"/mhn","./nl":"3K28","./nl-be":"Bp2f","./nl-be.js":"Bp2f","./nl.js":"3K28","./nn":"C7av","./nn.js":"C7av","./pa-in":"pfs9","./pa-in.js":"pfs9","./pl":"7LV+","./pl.js":"7LV+","./pt":"ZoSI","./pt-br":"AoDM","./pt-br.js":"AoDM","./pt.js":"ZoSI","./ro":"wT5f","./ro.js":"wT5f","./ru":"ulq9","./ru.js":"ulq9","./sd":"fW1y","./sd.js":"fW1y","./se":"5Omq","./se.js":"5Omq","./si":"Lgqo","./si.js":"Lgqo","./sk":"OUMt","./sk.js":"OUMt","./sl":"2s1U","./sl.js":"2s1U","./sq":"V0td","./sq.js":"V0td","./sr":"f4W3","./sr-cyrl":"c1x4","./sr-cyrl.js":"c1x4","./sr.js":"f4W3","./ss":"7Q8x","./ss.js":"7Q8x","./sv":"Fpqq","./sv.js":"Fpqq","./sw":"DSXN","./sw.js":"DSXN","./ta":"+7/x","./ta.js":"+7/x","./te":"Nlnz","./te.js":"Nlnz","./tet":"gUgh","./tet.js":"gUgh","./th":"XzD+","./th.js":"XzD+","./tl-ph":"3LKG","./tl-ph.js":"3LKG","./tlh":"m7yE","./tlh.js":"m7yE","./tr":"k+5o","./tr.js":"k+5o","./tzl":"iNtv","./tzl.js":"iNtv","./tzm":"FRPF","./tzm-latn":"krPU","./tzm-latn.js":"krPU","./tzm.js":"FRPF","./uk":"ntHu","./uk.js":"ntHu","./ur":"uSe8","./ur.js":"uSe8","./uz":"XU1s","./uz-latn":"/bsm","./uz-latn.js":"/bsm","./uz.js":"XU1s","./vi":"0X8Q","./vi.js":"0X8Q","./x-pseudo":"e/KL","./x-pseudo.js":"e/KL","./yo":"YXlc","./yo.js":"YXlc","./zh-cn":"Vz2w","./zh-cn.js":"Vz2w","./zh-hk":"ZUyn","./zh-hk.js":"ZUyn","./zh-tw":"BbgG","./zh-tw.js":"BbgG"};a.keys=function(){return Object.keys(o)},a.resolve=i,e.exports=a,a.id="uslO"},w1qT:function(e,n){e.exports="#define GLSLIFY 1\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\n//varying float vReflectionFactor;\nvarying vec3 worldNormal;\n\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight.rgb, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"},"wIG/":function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var i=t("//Fk"),o=a(i),r=t("Zrlr"),s=a(r),l=t("wxAW"),u=a(l),d=t("mtWM"),f=a(d),c=t("Sazm"),m=a(c);t("3VHS");var h=function(){function e(){(0,s.default)(this,e),this.init()}return(0,u.default)(e,[{key:"init",value:function(){this.initDataStore()}},{key:"initDataStore",value:function(){m.default.initializeApp({apiKey:"AIzaSyCkC_zpHJhgYkS-IbN_OwvZSjb4NfcN28g",projectId:"iohk-orpheus"}),this.blocks=m.default.firestore().collection("block")}},{key:"formatTimeSeries",value:function(e){var n=e.data,t=[],a=[];return n.values.forEach(function(e){var n=e.x,i=e.y;t.push(n),a.push(i)}),{times:t,values:a}}},{key:"getTransactionFeesOverTime",value:function(e,n){f.default.get("https://api.blockchain.info/charts/transaction-fees?timespan=all&format=json&cors=true").then(this.formatTimeSeries)}},{key:"getTransactionVolumeOverTime",value:function(e,n){f.default.get("https://api.blockchain.info/charts/estimated-transaction-volume?format=json&cors=true").then(this.formatTimeSeries)}},{key:"getHashRateforDay",value:function(e){var n=this;f.default.get("https://api.blockchain.info/charts/hash-rate?timespan=1days&format=json&start="+e+"&cors=true").then(function(e){var t=n.formatTimeSeries(e);return t&&void 0!==t.values[0]&&t.values[0]})}},{key:"assignHashRates",value:function(e){var n=this,t=e.length,a=0;return new o.default(function(i,o){e.forEach(function(o){var r=o.timeStamp/1e3;n.getHashRateforDay(r).then(function(n){o.hashRate=n,++a===t&&(null===e[0].hashRate&&(e[0].hashRate=e[1].hashRate),i())}).catch(function(e){a++,o.hashRate=null,console.log(e)})})})}},{key:"getBlock",value:function(e){return this.blocks.where("hash","==",e).get().then(function(e){return e.docs[0].data()})}},{key:"getBlocksOnDay",value:function(e,n){var t=new Date(e);t.setMilliseconds(0),t.setSeconds(0),t.setMinutes(0),t.setHours(0);var a=new Date(t.getTime());return a.setHours(a.getHours()+24),this.getBlocksSince(t,a)}},{key:"getBlocksSince",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Date;return this.blocks.orderBy("time","asc").startAt(e/1e3).endAt(n/1e3).get().then(function(e){return e.docs.map(function(e){return e.data()})})}},{key:"getDay",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Date;return this.getBlocksSince(e,n).then(function(n){var t=n.reduce(function(e,n){return e+n.fee},0)||0,a=n.reduce(function(e,n){return e+n.input},0)||0,i=n.reduce(function(e,n){return e+n.output},0)||0;return{date:e,blocks:n,fee:t,input:a,output:i}})}},{key:"getLatestBlock",value:function(){this.blocks.orderBy("time","desc").limit(1).get().then(function(e){return e.docs[0].data()})}},{key:"getTransactionsForBlock",value:function(e){var n=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o.default(function(a,i){n.blocks.where("hash","==",e).get().then(function(e){return e.docs[0].ref.collection("metadata").get()}).then(function(n){try{a(n.docs[0].data().transaction)}catch(n){console.log("Block: "+e+" has no transactions in the DB!"),i(n)}}).catch(function(a){t<5?(console.log("Couldn't get transactions for block, retrying..."),n.getTransactionsForBlock(e,t+1).catch(function(e){i(e)})):(console.log("Couldn't get transactions for block, retry limit reached"),i(a))})})}}]),e}();n.default=h},xFsn:function(e,n,t){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}var i=t("Dd8w"),o=a(i),r=t("Ml+6"),s=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}(r),l=t("/w9m"),u=a(l),d=t("f82t"),f=a(d),c=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=new u.default;return new f.default((0,o.default)({},e,{stage:n}))};c.canRun=null!==window.WebGLRenderingContext&&null!==window.Worker,c.preload=function(e){return c.textureLoader=new s.TextureLoader},window.orpheusApp=c}},["xFsn"]);
//# sourceMappingURL=app.4d5e6e6584f8fd78fc43.js.map